.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "MCRFPY" "3" "2025-12-28" "McRogueFace dev" ""
.hy
.SH McRogueFace API Reference
.PP
\f[I]Generated on 2025-12-28 14:29:42\f[R]
.PP
\f[I]This documentation was dynamically generated from the compiled
module.\f[R]
.SS Table of Contents
.IP \[bu] 2
Functions
.IP \[bu] 2
Classes
.RS 2
.IP \[bu] 2
Animation
.IP \[bu] 2
Arc
.IP \[bu] 2
Caption
.IP \[bu] 2
Circle
.IP \[bu] 2
Color
.IP \[bu] 2
ColorLayer
.IP \[bu] 2
Drawable
.IP \[bu] 2
Entity
.IP \[bu] 2
EntityCollection
.IP \[bu] 2
FOV
.IP \[bu] 2
Font
.IP \[bu] 2
Frame
.IP \[bu] 2
Grid
.IP \[bu] 2
GridPoint
.IP \[bu] 2
GridPointState
.IP \[bu] 2
Line
.IP \[bu] 2
Scene
.IP \[bu] 2
Sprite
.IP \[bu] 2
Texture
.IP \[bu] 2
TileLayer
.IP \[bu] 2
Timer
.IP \[bu] 2
UICollection
.IP \[bu] 2
UICollectionIter
.IP \[bu] 2
UIEntityCollectionIter
.IP \[bu] 2
Vector
.IP \[bu] 2
Window
.RE
.IP \[bu] 2
Constants
.SS Functions
.SS \f[V]createScene(name: str) -> None\f[R]
.PP
Create a new empty scene.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]name\f[R]: Unique name for the new scene
.PP
\f[B]Returns:\f[R] None
.PP
\f[B]Raises:\f[R] ValueError: If a scene with this name already exists
The scene is created but not made active.
Use setScene() to switch to it.
.SS \f[V]createSoundBuffer(filename: str) -> int\f[R]
.PP
Load a sound effect from a file and return its buffer ID.
.PP
\f[B]Arguments:\f[R] - \f[V]filename\f[R]: Path to the sound file (WAV,
OGG, FLAC)
.PP
\f[B]Returns:\f[R] int: Buffer ID for use with playSound()
.PP
\f[B]Raises:\f[R] RuntimeError: If the file cannot be loaded
.SS \f[V]currentScene() -> str\f[R]
.PP
Get the name of the currently active scene.
.PP
\f[B]Returns:\f[R] str: Name of the current scene
.SS \f[V]delTimer(name: str) -> None\f[R]
.PP
Stop and remove a timer.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]name\f[R]: Timer identifier to remove
.PP
\f[B]Returns:\f[R] None No error is raised if the timer doesn\[cq]t
exist.
.SS \f[V]end_benchmark() -> str\f[R]
.PP
Stop benchmark capture and write data to JSON file.
.PP
Note:
.PP
\f[B]Returns:\f[R] str: The filename of the written benchmark data
.PP
\f[B]Raises:\f[R] RuntimeError: If no benchmark is currently running
Returns the auto-generated filename (e.g.,
`benchmark_12345_20250528_143022.json')
.SS \f[V]exit() -> None\f[R]
.PP
Cleanly shut down the game engine and exit the application.
.PP
Note:
.PP
\f[B]Returns:\f[R] None This immediately closes the window and
terminates the program.
.SS \f[V]find(name: str, scene: str = None) -> UIDrawable | None\f[R]
.PP
Find the first UI element with the specified name.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]name\f[R]: Exact name to search for -
\f[V]scene\f[R]: Scene to search in (default: current scene)
.PP
\f[B]Returns:\f[R] Frame, Caption, Sprite, Grid, or Entity if found;
None otherwise Searches scene UI elements and entities within grids.
.SS \f[V]findAll(pattern: str, scene: str = None) -> list\f[R]
.PP
Find all UI elements matching a name pattern.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]pattern\f[R]: Name pattern with optional
wildcards (* matches any characters) - \f[V]scene\f[R]: Scene to search
in (default: current scene)
.PP
\f[B]Returns:\f[R] list: All matching UI elements and entities
.SS \f[V]getMetrics() -> dict\f[R]
.PP
Get current performance metrics.
.PP
\f[B]Returns:\f[R] dict: Performance data with keys: frame_time (last
frame duration in seconds), avg_frame_time (average frame time), fps
(frames per second), draw_calls (number of draw calls), ui_elements
(total UI element count), visible_elements (visible element count),
current_frame (frame counter), runtime (total runtime in seconds)
.SS \f[V]getMusicVolume() -> int\f[R]
.PP
Get the current music volume level.
.PP
\f[B]Returns:\f[R] int: Current volume (0-100)
.SS \f[V]getSoundVolume() -> int\f[R]
.PP
Get the current sound effects volume level.
.PP
\f[B]Returns:\f[R] int: Current volume (0-100)
.SS \f[V]keypressScene(handler: callable) -> None\f[R]
.PP
Set the keyboard event handler for the current scene.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]handler\f[R]: Callable that receives
(key_name: str, is_pressed: bool)
.PP
\f[B]Returns:\f[R] None
.SS \f[V]loadMusic(filename: str) -> None\f[R]
.PP
Load and immediately play background music from a file.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]filename\f[R]: Path to the music file (WAV,
OGG, FLAC)
.PP
\f[B]Returns:\f[R] None Only one music track can play at a time.
Loading new music stops the current track.
.SS \f[V]log_benchmark(message: str) -> None\f[R]
.PP
Add a log message to the current benchmark frame.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]message\f[R]: Text to associate with the
current frame
.PP
\f[B]Returns:\f[R] None
.PP
\f[B]Raises:\f[R] RuntimeError: If no benchmark is currently running
Messages appear in the `logs' array of each frame in the output JSON.
.SS \f[V]playSound(buffer_id: int) -> None\f[R]
.PP
Play a sound effect using a previously loaded buffer.
.PP
\f[B]Arguments:\f[R] - \f[V]buffer_id\f[R]: Sound buffer ID returned by
createSoundBuffer()
.PP
\f[B]Returns:\f[R] None
.PP
\f[B]Raises:\f[R] RuntimeError: If the buffer ID is invalid
.SS \f[V]sceneUI(scene: str = None) -> list\f[R]
.PP
Get all UI elements for a scene.
.PP
\f[B]Arguments:\f[R] - \f[V]scene\f[R]: Scene name.
If None, uses current scene
.PP
\f[B]Returns:\f[R] list: All UI elements (Frame, Caption, Sprite, Grid)
in the scene
.PP
\f[B]Raises:\f[R] KeyError: If the specified scene doesn\[cq]t exist
.SS \f[V]setDevConsole(enabled: bool) -> None\f[R]
.PP
Enable or disable the developer console overlay.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]enabled\f[R]: True to enable the console
(default), False to disable
.PP
\f[B]Returns:\f[R] None When disabled, the grave/tilde key will not open
the console.
Use this to ship games without debug features.
.SS \f[V]setMusicVolume(volume: int) -> None\f[R]
.PP
Set the global music volume.
.PP
\f[B]Arguments:\f[R] - \f[V]volume\f[R]: Volume level from 0 (silent) to
100 (full volume)
.PP
\f[B]Returns:\f[R] None
.SS \f[V]setScale(multiplier: float) -> None\f[R]
.PP
Scale the game window size.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]multiplier\f[R]: Scale factor (e.g., 2.0 for
double size)
.PP
\f[B]Returns:\f[R] None The internal resolution remains 1024x768, but
the window is scaled.
This is deprecated - use Window.resolution instead.
.SS \f[V]setScene(scene: str, transition: str = None, duration: float = 0.0) -> None\f[R]
.PP
Switch to a different scene with optional transition effect.
.PP
\f[B]Arguments:\f[R] - \f[V]scene\f[R]: Name of the scene to switch to -
\f[V]transition\f[R]: Transition type (`fade', `slide_left',
`slide_right', `slide_up', `slide_down') - \f[V]duration\f[R]:
Transition duration in seconds (default: 0.0 for instant)
.PP
\f[B]Returns:\f[R] None
.PP
\f[B]Raises:\f[R] KeyError: If the scene doesn\[cq]t exist ValueError:
If the transition type is invalid
.SS \f[V]setSoundVolume(volume: int) -> None\f[R]
.PP
Set the global sound effects volume.
.PP
\f[B]Arguments:\f[R] - \f[V]volume\f[R]: Volume level from 0 (silent) to
100 (full volume)
.PP
\f[B]Returns:\f[R] None
.SS \f[V]setTimer(name: str, handler: callable, interval: int) -> None\f[R]
.PP
Create or update a recurring timer.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]name\f[R]: Unique identifier for the timer -
\f[V]handler\f[R]: Function called with (runtime: float) parameter -
\f[V]interval\f[R]: Time between calls in milliseconds
.PP
\f[B]Returns:\f[R] None If a timer with this name exists, it will be
replaced.
The handler receives the total runtime in seconds as its argument.
.SS \f[V]start_benchmark() -> None\f[R]
.PP
Start capturing benchmark data to a file.
.PP
Note:
.PP
\f[B]Returns:\f[R] None
.PP
\f[B]Raises:\f[R] RuntimeError: If a benchmark is already running
Benchmark filename is auto-generated from PID and timestamp.
Use end_benchmark() to stop and get filename.
.SS \f[V]step(dt: float = None) -> float\f[R]
.PP
Advance simulation time (headless mode only).
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dt\f[R]: Time to advance in seconds.
If None, advances to the next scheduled event (timer/animation).
.PP
\f[B]Returns:\f[R] float: Actual time advanced in seconds.
Returns 0.0 in windowed mode.
In windowed mode, this is a no-op and returns 0.0.
Use this for deterministic simulation control in headless/testing
scenarios.
.SS Classes
.SS Animation
.PP
Animation object for animating UI properties
.PP
\f[B]Methods:\f[R]
.SS \f[V]complete() -> None\f[R]
.PP
Complete the animation immediately by jumping to the final value.
.PP
Note:
.PP
\f[B]Returns:\f[R] None Sets elapsed = duration and applies target value
immediately.
Completion callback will be called if set.
.SS \f[V]get_current_value() -> Any\f[R]
.PP
Get the current interpolated value of the animation.
.PP
Note:
.PP
\f[B]Returns:\f[R] Any: Current value (type depends on property: float,
int, Color tuple, Vector tuple, or str) Return type matches the target
property type.
For sprite_index returns int, for pos returns (x, y), for fill_color
returns (r, g, b, a).
.SS \f[V]hasValidTarget() -> bool\f[R]
.PP
Check if the animation still has a valid target.
.PP
Note:
.PP
\f[B]Returns:\f[R] bool: True if the target still exists, False if it
was destroyed Animations automatically clean up when targets are
destroyed.
Use this to check if manual cleanup is needed.
.SS \f[V]start(target: UIDrawable, conflict_mode: str = \[aq]replace\[aq]) -> None\f[R]
.PP
Start the animation on a target UI element.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]target\f[R]: The UI element to animate
(Frame, Caption, Sprite, Grid, or Entity) - \f[V]conflict_mode\f[R]: How
to handle conflicts if property is already animating: `replace'
(default) - complete existing animation and start new one; `queue' -
wait for existing animation to complete; `error' - raise RuntimeError if
property is busy
.PP
\f[B]Returns:\f[R] None
.PP
\f[B]Raises:\f[R] RuntimeError: When conflict_mode=`error' and property
is already animating The animation will automatically stop if the target
is destroyed.
.SS \f[V]update(delta_time: float) -> bool\f[R]
.PP
Update the animation by the given time delta.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]delta_time\f[R]: Time elapsed since last
update in seconds
.PP
\f[B]Returns:\f[R] bool: True if animation is still running, False if
complete Typically called by AnimationManager automatically.
Manual calls only needed for custom animation control.
.SS Arc
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Arc(center=None, radius=0, start_angle=0, end_angle=90, color=None,
thickness=1, **kwargs)
.PP
An arc UI element for drawing curved line segments.
.PP
Args: center (tuple, optional): Center position as (x, y).
Default: (0, 0) radius (float, optional): Arc radius in pixels.
Default: 0 start_angle (float, optional): Starting angle in degrees.
Default: 0 end_angle (float, optional): Ending angle in degrees.
Default: 90 color (Color, optional): Arc color.
Default: White thickness (float, optional): Line thickness.
Default: 1.0
.PP
Keyword Args: on_click (callable): Click handler.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None
.PP
Attributes: center (Vector): Center position radius (float): Arc radius
start_angle (float): Starting angle in degrees end_angle (float): Ending
angle in degrees color (Color): Arc color thickness (float): Line
thickness visible (bool): Visibility state opacity (float): Opacity
value z_index (int): Rendering order name (str): Element name
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Caption
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Caption(pos=None, font=None, text=\[cq]\[cq], **kwargs)
.PP
A text display UI element with customizable font and styling.
.PP
Args: pos (tuple, optional): Position as (x, y) tuple.
Default: (0, 0) font (Font, optional): Font object for text rendering.
Default: engine default font text (str, optional): The text content to
display.
Default: \[cq]\[cq]
.PP
Keyword Args: fill_color (Color): Text fill color.
Default: (255, 255, 255, 255) outline_color (Color): Text outline color.
Default: (0, 0, 0, 255) outline (float): Text outline thickness.
Default: 0 font_size (float): Font size in points.
Default: 16 click (callable): Click event handler.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None x (float): X position override.
Default: 0 y (float): Y position override.
Default: 0
.PP
Attributes: text (str): The displayed text content x, y (float):
Position in pixels pos (Vector): Position as a Vector object font
(Font): Font used for rendering font_size (float): Font size in points
fill_color, outline_color (Color): Text appearance outline (float):
Outline thickness click (callable): Click event handler visible (bool):
Visibility state opacity (float): Opacity value z_index (int): Rendering
order name (str): Element name w, h (float): Read-only computed size
based on text and font
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Circle
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Circle(radius=0, center=None, fill_color=None, outline_color=None,
outline=0, **kwargs)
.PP
A circle UI element for drawing filled or outlined circles.
.PP
Args: radius (float, optional): Circle radius in pixels.
Default: 0 center (tuple, optional): Center position as (x, y).
Default: (0, 0) fill_color (Color, optional): Fill color.
Default: White outline_color (Color, optional): Outline color.
Default: Transparent outline (float, optional): Outline thickness.
Default: 0 (no outline)
.PP
Keyword Args: on_click (callable): Click handler.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None
.PP
Attributes: radius (float): Circle radius center (Vector): Center
position fill_color (Color): Fill color outline_color (Color): Outline
color outline (float): Outline thickness visible (bool): Visibility
state opacity (float): Opacity value z_index (int): Rendering order name
(str): Element name
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Color
.PP
SFML Color Object
.PP
\f[B]Methods:\f[R]
.SS \f[V]from_hex(hex_string: str) -> Color\f[R]
.PP
Create a Color from a hexadecimal string.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]hex_string\f[R]: Hex color string (e.g.,
`#FF0000', `FF0000', `#AABBCCDD' for RGBA)
.PP
\f[B]Returns:\f[R] Color: New Color object with values from hex string
.PP
\f[B]Raises:\f[R] ValueError: If hex string is not 6 or 8 characters
(RGB or RGBA) This is a class method.
Call as Color.from_hex(`#FF0000')
.SS \f[V]lerp(other: Color, t: float) -> Color\f[R]
.PP
Linearly interpolate between this color and another.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]other\f[R]: The target Color to interpolate
towards - \f[V]t\f[R]: Interpolation factor (0.0 = this color, 1.0 =
other color).
Automatically clamped to [0.0, 1.0]
.PP
\f[B]Returns:\f[R] Color: New Color representing the interpolated value
All components (r, g, b, a) are interpolated independently
.SS \f[V]to_hex() -> str\f[R]
.PP
Convert this Color to a hexadecimal string.
.PP
Note:
.PP
\f[B]Returns:\f[R] str: Hex string in format `#RRGGBB' or `#RRGGBBAA'
(if alpha < 255) Alpha component is only included if not fully opaque (<
255)
.SS ColorLayer
.PP
ColorLayer(z_index=-1, grid_size=None)
.PP
A grid layer that stores RGBA colors per cell.
.PP
Args: z_index (int): Render order.
Negative = below entities.
Default: -1 grid_size (tuple): Dimensions as (width, height).
Default: parent grid size
.PP
Attributes: z_index (int): Layer z-order relative to entities visible
(bool): Whether layer is rendered grid_size (tuple): Layer dimensions
(read-only)
.PP
Methods: at(x, y): Get color at cell position set(x, y, color): Set
color at cell position fill(color): Fill entire layer with color
.PP
\f[B]Methods:\f[R]
.SS \f[V]apply_perspective(entity, visible=None, discovered=None, unknown=None)\f[R]
.PP
Bind this layer to an entity for automatic FOV updates.
.SS \f[V]at(x, y) -> Color\f[R]
.PP
Get the color at cell position (x, y).
.SS \f[V]clear_perspective()\f[R]
.PP
Remove the perspective binding from this layer.
.SS \f[V]draw_fov(source, radius=None, fov=None, visible=None, discovered=None, unknown=None)\f[R]
.PP
Paint cells based on field-of-view visibility from source position.
.PP
Note: Layer must be attached to a grid for FOV calculation.
.SS \f[V]fill(color)\f[R]
.PP
Fill the entire layer with the specified color.
.SS \f[V]fill_rect(pos, size, color)\f[R]
.PP
Fill a rectangular region with a color.
.PP
\f[B]Arguments:\f[R] - \f[V]color\f[R]: Color object or (r, g, b[, a])
tuple
.SS \f[V]set(x, y, color)\f[R]
.PP
Set the color at cell position (x, y).
.SS \f[V]update_perspective()\f[R]
.PP
Redraw FOV based on the bound entity\[cq]s current position.
Call this after the entity moves to update the visibility layer.
.SS Drawable
.PP
Base class for all drawable UI elements
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Entity
.PP
Entity(grid_pos=None, texture=None, sprite_index=0, **kwargs)
.PP
A game entity that exists on a grid with sprite rendering.
.PP
Args: grid_pos (tuple, optional): Grid position as (x, y) tuple.
Default: (0, 0) texture (Texture, optional): Texture object for sprite.
Default: default texture sprite_index (int, optional): Index into
texture atlas.
Default: 0
.PP
Keyword Args: grid (Grid): Grid to attach entity to.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 name (str): Element name for finding.
Default: None x (float): X grid position override.
Default: 0 y (float): Y grid position override.
Default: 0
.PP
Attributes: pos (tuple): Grid position as (x, y) tuple x, y (float):
Grid position coordinates draw_pos (tuple): Pixel position for rendering
gridstate (GridPointState): Visibility state for grid points
sprite_index (int): Current sprite index visible (bool): Visibility
state opacity (float): Opacity value name (str): Element name
.PP
\f[B]Methods:\f[R]
.SS \f[V]at(...)\f[R]
.SS \f[V]die(...)\f[R]
.PP
Remove this entity from its grid
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]index(...)\f[R]
.PP
Return the index of this entity in its grid\[cq]s entity collection
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]path_to(x: int, y: int) -> bool\f[R]
.PP
Find and follow path to target position using A* pathfinding.
.PP
\f[B]Arguments:\f[R] - \f[V]x\f[R]: Target X coordinate - \f[V]y\f[R]:
Target Y coordinate
.PP
\f[B]Returns:\f[R] True if a path was found and the entity started
moving, False otherwise The entity will automatically move along the
path over multiple frames.
Call this again to change the target or repath.
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS \f[V]update_visibility() -> None\f[R]
.PP
Update entity\[cq]s visibility state based on current FOV.
Recomputes which cells are visible from the entity\[cq]s position and
updates the entity\[cq]s gridstate to track explored areas.
This is called automatically when the entity moves if it has a grid with
perspective set.
.SS \f[V]visible_entities(fov=None, radius=None) -> list[Entity]\f[R]
.PP
Get list of other entities visible from this entity\[cq]s position.
.PP
\f[B]Returns:\f[R] List of Entity objects that are within field of view.
Computes FOV from this entity\[cq]s position and returns all other
entities whose positions fall within the visible area.
.SS EntityCollection
.PP
Iterable, indexable collection of Entities
.PP
\f[B]Methods:\f[R]
.SS \f[V]append(entity)\f[R]
.PP
Add an entity to the end of the collection.
.SS \f[V]count(entity) -> int\f[R]
.PP
Count occurrences of entity in the collection.
.SS \f[V]extend(iterable)\f[R]
.PP
Add all entities from an iterable to the collection.
.SS \f[V]find(name) -> entity or list\f[R]
.PP
Find entities by name.
.PP
\f[B]Returns:\f[R] Single entity if exact match, list if wildcard, None
if not found.
.SS \f[V]index(entity) -> int\f[R]
.PP
Return index of first occurrence of entity.
Raises ValueError if not found.
.SS \f[V]insert(index, entity)\f[R]
.PP
Insert entity at index.
Like list.insert(), indices past the end append.
.SS \f[V]pop([index]) -> entity\f[R]
.PP
Remove and return entity at index (default: last entity).
.SS \f[V]remove(entity)\f[R]
.PP
Remove first occurrence of entity.
Raises ValueError if not found.
.SS FOV
.PP
\f[I]Inherits from: IntEnum\f[R]
.PP
\f[B]Methods:\f[R]
.SS \f[V]as_integer_ratio(...)\f[R]
.PP
Return a pair of integers, whose ratio is equal to the original int.
The ratio is in lowest terms and has a positive denominator.
>>> (10).as_integer_ratio() (10, 1) >>> (-10).as_integer_ratio() (-10,
1) >>> (0).as_integer_ratio() (0, 1)
.SS \f[V]bit_count(...)\f[R]
.PP
Number of ones in the binary representation of the absolute value of
self.
Also known as the population count.
>>> bin(13) `0b1101' >>> (13).bit_count() 3
.SS \f[V]bit_length(...)\f[R]
.PP
Number of bits necessary to represent self in binary.
>>> bin(37) `0b100101' >>> (37).bit_length() 6
.SS \f[V]conjugate(...)\f[R]
.PP
Returns self, the complex conjugate of any int.
.SS \f[V]from_bytes(...)\f[R]
.PP
Return the integer represented by the given array of bytes.
bytes Holds the array of bytes to convert.
The argument must either support the buffer protocol or be an iterable
object producing bytes.
Bytes and bytearray are examples of built-in objects that support the
buffer protocol.
byteorder The byte order used to represent the integer.
If byteorder is `big', the most significant byte is at the beginning of
the byte array.
If byteorder is `little', the most significant byte is at the end of the
byte array.
To request the native byte order of the host system, use sys.byteorder
as the byte order value.
Default is to use `big'.
signed Indicates whether two\[cq]s complement is used to represent the
integer.
.SS \f[V]is_integer(...)\f[R]
.PP
Returns True.
Exists for duck type compatibility with float.is_integer.
.SS \f[V]to_bytes(...)\f[R]
.PP
Return an array of bytes representing an integer.
length Length of bytes object to use.
An OverflowError is raised if the integer is not representable with the
given number of bytes.
Default is length 1.
byteorder The byte order used to represent the integer.
If byteorder is `big', the most significant byte is at the beginning of
the byte array.
If byteorder is `little', the most significant byte is at the end of the
byte array.
To request the native byte order of the host system, use sys.byteorder
as the byte order value.
Default is to use `big'.
signed Determines whether two\[cq]s complement is used to represent the
integer.
If signed is False and a negative integer is given, an OverflowError is
raised.
.SS Font
.PP
SFML Font Object
.PP
\f[B]Methods:\f[R]
.SS Frame
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Frame(pos=None, size=None, **kwargs)
.PP
A rectangular frame UI element that can contain other drawable elements.
.PP
Args: pos (tuple, optional): Position as (x, y) tuple.
Default: (0, 0) size (tuple, optional): Size as (width, height) tuple.
Default: (0, 0)
.PP
Keyword Args: fill_color (Color): Background fill color.
Default: (0, 0, 0, 128) outline_color (Color): Border outline color.
Default: (255, 255, 255, 255) outline (float): Border outline thickness.
Default: 0 click (callable): Click event handler.
Default: None children (list): Initial list of child drawable elements.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None x (float): X position override.
Default: 0 y (float): Y position override.
Default: 0 w (float): Width override.
Default: 0 h (float): Height override.
Default: 0 clip_children (bool): Whether to clip children to frame
bounds.
Default: False cache_subtree (bool): Cache rendering to texture for
performance.
Default: False
.PP
Attributes: x, y (float): Position in pixels w, h (float): Size in
pixels pos (Vector): Position as a Vector object fill_color,
outline_color (Color): Visual appearance outline (float): Border
thickness click (callable): Click event handler children (list):
Collection of child drawable elements visible (bool): Visibility state
opacity (float): Opacity value z_index (int): Rendering order name
(str): Element name clip_children (bool): Whether to clip children to
frame bounds cache_subtree (bool): Cache subtree rendering to texture
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Grid
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Grid(pos=None, size=None, grid_size=None, texture=None, **kwargs)
.PP
A grid-based UI element for tile-based rendering and entity management.
.PP
Args: pos (tuple, optional): Position as (x, y) tuple.
Default: (0, 0) size (tuple, optional): Size as (width, height) tuple.
Default: auto-calculated from grid_size grid_size (tuple, optional):
Grid dimensions as (grid_x, grid_y) tuple.
Default: (2, 2) texture (Texture, optional): Texture containing tile
sprites.
Default: default texture
.PP
Keyword Args: fill_color (Color): Background fill color.
Default: None click (callable): Click event handler.
Default: None center_x (float): X coordinate of center point.
Default: 0 center_y (float): Y coordinate of center point.
Default: 0 zoom (float): Zoom level for rendering.
Default: 1.0 perspective (int): Entity perspective index (-1 for
omniscient).
Default: -1 visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None x (float): X position override.
Default: 0 y (float): Y position override.
Default: 0 w (float): Width override.
Default: auto-calculated h (float): Height override.
Default: auto-calculated grid_x (int): Grid width override.
Default: 2 grid_y (int): Grid height override.
Default: 2
.PP
Attributes: x, y (float): Position in pixels w, h (float): Size in
pixels pos (Vector): Position as a Vector object size (tuple): Size as
(width, height) tuple center (tuple): Center point as (x, y) tuple
center_x, center_y (float): Center point coordinates zoom (float): Zoom
level for rendering grid_size (tuple): Grid dimensions (width, height)
in tiles grid_x, grid_y (int): Grid dimensions texture (Texture): Tile
texture atlas fill_color (Color): Background color entities
(EntityCollection): Collection of entities in the grid perspective
(int): Entity perspective index click (callable): Click event handler
visible (bool): Visibility state opacity (float): Opacity value z_index
(int): Rendering order name (str): Element name
.PP
\f[B]Methods:\f[R]
.SS \f[V]add_layer(type: str, z_index: int = -1, texture: Texture = None) -> ColorLayer | TileLayer\f[R]
.PP
Add a new layer to the grid.
.PP
\f[B]Arguments:\f[R] - \f[V]type\f[R]: Layer type (`color' or `tile') -
\f[V]z_index\f[R]: Render order.
Negative = below entities, >= 0 = above entities.
Default: -1 - \f[V]texture\f[R]: Texture for tile layers.
Required for `tile' type.
.PP
\f[B]Returns:\f[R] The created ColorLayer or TileLayer object.
.SS \f[V]at(...)\f[R]
.SS \f[V]compute_astar_path(x1: int, y1: int, x2: int, y2: int, diagonal_cost: float = 1.41) -> List[Tuple[int, int]]\f[R]
.PP
Compute A* path between two points.
.PP
\f[B]Arguments:\f[R] - \f[V]x1\f[R]: Starting X coordinate -
\f[V]y1\f[R]: Starting Y coordinate - \f[V]x2\f[R]: Target X coordinate
- \f[V]y2\f[R]: Target Y coordinate - \f[V]diagonal_cost\f[R]: Cost of
diagonal movement (default: 1.41)
.PP
\f[B]Returns:\f[R] List of (x, y) tuples representing the path, empty
list if no path exists Alternative A* implementation.
Prefer find_path() for consistency.
.SS \f[V]compute_dijkstra(root_x: int, root_y: int, diagonal_cost: float = 1.41) -> None\f[R]
.PP
Compute Dijkstra map from root position.
.PP
\f[B]Arguments:\f[R] - \f[V]root_x\f[R]: X coordinate of the root/target
- \f[V]root_y\f[R]: Y coordinate of the root/target -
\f[V]diagonal_cost\f[R]: Cost of diagonal movement (default: 1.41)
.SS \f[V]compute_fov(x: int, y: int, radius: int = 0, light_walls: bool = True, algorithm: int = FOV_BASIC) -> None\f[R]
.PP
Compute field of view from a position.
.PP
\f[B]Arguments:\f[R] - \f[V]x\f[R]: X coordinate of the viewer -
\f[V]y\f[R]: Y coordinate of the viewer - \f[V]radius\f[R]: Maximum view
distance (0 = unlimited) - \f[V]light_walls\f[R]: Whether walls are lit
when visible - \f[V]algorithm\f[R]: FOV algorithm to use (FOV_BASIC,
FOV_DIAMOND, FOV_SHADOW, FOV_PERMISSIVE_0-8)
.SS \f[V]entities_in_radius(x: float, y: float, radius: float) -> list[Entity]\f[R]
.PP
Query entities within radius using spatial hash (O(k) where k = nearby
entities).
.PP
\f[B]Arguments:\f[R] - \f[V]x\f[R]: Center X coordinate - \f[V]y\f[R]:
Center Y coordinate - \f[V]radius\f[R]: Search radius
.PP
\f[B]Returns:\f[R] List of Entity objects within the radius.
.SS \f[V]find_path(x1: int, y1: int, x2: int, y2: int, diagonal_cost: float = 1.41) -> List[Tuple[int, int]]\f[R]
.PP
Find A* path between two points.
.PP
\f[B]Arguments:\f[R] - \f[V]x1\f[R]: Starting X coordinate -
\f[V]y1\f[R]: Starting Y coordinate - \f[V]x2\f[R]: Target X coordinate
- \f[V]y2\f[R]: Target Y coordinate - \f[V]diagonal_cost\f[R]: Cost of
diagonal movement (default: 1.41)
.PP
\f[B]Returns:\f[R] List of (x, y) tuples representing the path, empty
list if no path exists Uses A* algorithm with walkability from grid
cells.
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]get_dijkstra_distance(x: int, y: int) -> Optional[float]\f[R]
.PP
Get distance from Dijkstra root to position.
.PP
\f[B]Arguments:\f[R] - \f[V]x\f[R]: X coordinate to query - \f[V]y\f[R]:
Y coordinate to query
.PP
\f[B]Returns:\f[R] Distance as float, or None if position is unreachable
or invalid Must call compute_dijkstra() first.
.SS \f[V]get_dijkstra_path(x: int, y: int) -> List[Tuple[int, int]]\f[R]
.PP
Get path from position to Dijkstra root.
.PP
\f[B]Arguments:\f[R] - \f[V]x\f[R]: Starting X coordinate - \f[V]y\f[R]:
Starting Y coordinate
.PP
\f[B]Returns:\f[R] List of (x, y) tuples representing path to root,
empty if unreachable Must call compute_dijkstra() first.
Path includes start but not root position.
.SS \f[V]is_in_fov(x: int, y: int) -> bool\f[R]
.PP
Check if a cell is in the field of view.
.PP
\f[B]Arguments:\f[R] - \f[V]x\f[R]: X coordinate to check - \f[V]y\f[R]:
Y coordinate to check
.PP
\f[B]Returns:\f[R] True if the cell is visible, False otherwise Must
call compute_fov() first to calculate visibility.
.SS \f[V]layer(z_index: int) -> ColorLayer | TileLayer | None\f[R]
.PP
Get a layer by its z_index.
.PP
\f[B]Arguments:\f[R] - \f[V]z_index\f[R]: The z_index of the layer to
find.
.PP
\f[B]Returns:\f[R] The layer with the specified z_index, or None if not
found.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]remove_layer(layer: ColorLayer | TileLayer) -> None\f[R]
.PP
Remove a layer from the grid.
.PP
\f[B]Arguments:\f[R] - \f[V]layer\f[R]: The layer to remove.
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS GridPoint
.PP
UIGridPoint object
.PP
\f[B]Methods:\f[R]
.SS GridPointState
.PP
UIGridPointState object
.PP
\f[B]Methods:\f[R]
.SS Line
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Line(start=None, end=None, thickness=1.0, color=None, **kwargs)
.PP
A line UI element for drawing straight lines between two points.
.PP
Args: start (tuple, optional): Starting point as (x, y).
Default: (0, 0) end (tuple, optional): Ending point as (x, y).
Default: (0, 0) thickness (float, optional): Line thickness in pixels.
Default: 1.0 color (Color, optional): Line color.
Default: White
.PP
Keyword Args: on_click (callable): Click handler.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None
.PP
Attributes: start (Vector): Starting point end (Vector): Ending point
thickness (float): Line thickness color (Color): Line color visible
(bool): Visibility state opacity (float): Opacity value z_index (int):
Rendering order name (str): Element name
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Scene
.PP
Base class for object-oriented scenes
.PP
\f[B]Methods:\f[R]
.SS \f[V]activate() -> None\f[R]
.PP
Make this the active scene.
.PP
Note:
.PP
\f[B]Returns:\f[R] None Deactivates the current scene and activates this
one.
Scene transitions and lifecycle callbacks are triggered.
.SS \f[V]register_keyboard(callback: callable) -> None\f[R]
.PP
Register a keyboard event handler function.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]callback\f[R]: Function that receives (key:
str, pressed: bool) when keyboard events occur
.PP
\f[B]Returns:\f[R] None Alternative to setting on_key property.
Handler is called for both key press and release events.
.SS Sprite
.PP
\f[I]Inherits from: Drawable\f[R]
.PP
Sprite(pos=None, texture=None, sprite_index=0, **kwargs)
.PP
A sprite UI element that displays a texture or portion of a texture
atlas.
.PP
Args: pos (tuple, optional): Position as (x, y) tuple.
Default: (0, 0) texture (Texture, optional): Texture object to display.
Default: default texture sprite_index (int, optional): Index into
texture atlas.
Default: 0
.PP
Keyword Args: scale (float): Uniform scale factor.
Default: 1.0 scale_x (float): Horizontal scale factor.
Default: 1.0 scale_y (float): Vertical scale factor.
Default: 1.0 click (callable): Click event handler.
Default: None visible (bool): Visibility state.
Default: True opacity (float): Opacity (0.0-1.0).
Default: 1.0 z_index (int): Rendering order.
Default: 0 name (str): Element name for finding.
Default: None x (float): X position override.
Default: 0 y (float): Y position override.
Default: 0
.PP
Attributes: x, y (float): Position in pixels pos (Vector): Position as a
Vector object texture (Texture): The texture being displayed
sprite_index (int): Current sprite index in texture atlas scale (float):
Uniform scale factor scale_x, scale_y (float): Individual scale factors
click (callable): Click event handler visible (bool): Visibility state
opacity (float): Opacity value z_index (int): Rendering order name
(str): Element name w, h (float): Read-only computed size based on
texture and scale
.PP
\f[B]Methods:\f[R]
.SS \f[V]get_bounds() -> tuple\f[R]
.PP
Get the bounding rectangle of this drawable element.
.PP
Note:
.PP
\f[B]Returns:\f[R] tuple: (x, y, width, height) representing the
element\[cq]s bounds The bounds are in screen coordinates and account
for current position and size.
.SS \f[V]move(dx: float, dy: float) -> None\f[R]
.PP
Move the element by a relative offset.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]dx\f[R]: Horizontal offset in pixels -
\f[V]dy\f[R]: Vertical offset in pixels
.SS \f[V]resize(width: float, height: float) -> None\f[R]
.PP
Resize the element to new dimensions.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]width\f[R]: New width in pixels -
\f[V]height\f[R]: New height in pixels
.SS Texture
.PP
SFML Texture Object
.PP
\f[B]Methods:\f[R]
.SS TileLayer
.PP
TileLayer(z_index=-1, texture=None, grid_size=None)
.PP
A grid layer that stores sprite indices per cell.
.PP
Args: z_index (int): Render order.
Negative = below entities.
Default: -1 texture (Texture): Sprite atlas for tile rendering.
Default: None grid_size (tuple): Dimensions as (width, height).
Default: parent grid size
.PP
Attributes: z_index (int): Layer z-order relative to entities visible
(bool): Whether layer is rendered texture (Texture): Tile sprite atlas
grid_size (tuple): Layer dimensions (read-only)
.PP
Methods: at(x, y): Get tile index at cell position set(x, y, index): Set
tile index at cell position fill(index): Fill entire layer with tile
index
.PP
\f[B]Methods:\f[R]
.SS \f[V]at(x, y) -> int\f[R]
.PP
Get the tile index at cell position (x, y).
Returns -1 if no tile.
.SS \f[V]fill(index)\f[R]
.PP
Fill the entire layer with the specified tile index.
.SS \f[V]fill_rect(pos, size, index)\f[R]
.PP
Fill a rectangular region with a tile index.
.SS \f[V]set(x, y, index)\f[R]
.PP
Set the tile index at cell position (x, y).
Use -1 for no tile.
.SS Timer
.PP
Timer(name, callback, interval, once=False)
.PP
Create a timer that calls a function at regular intervals.
.PP
Args: name (str): Unique identifier for the timer callback (callable):
Function to call - receives (timer, runtime) args interval (int): Time
between calls in milliseconds once (bool): If True, timer stops after
first call.
Default: False
.PP
Attributes: interval (int): Time between calls in milliseconds remaining
(int): Time until next call in milliseconds (read-only) paused (bool):
Whether timer is paused (read-only) active (bool): Whether timer is
active and not paused (read-only) callback (callable): The callback
function once (bool): Whether timer stops after firing once
.PP
Methods: pause(): Pause the timer, preserving time remaining resume():
Resume a paused timer cancel(): Stop and remove the timer restart():
Reset timer to start from beginning
.PP
Example: def on_timer(timer, runtime): print(f\[cq]Timer {timer} fired
at {runtime}ms\[cq]) if runtime > 5000: timer.cancel()
.IP
.nf
\f[C]
timer = mcrfpy.Timer(\[aq]my_timer\[aq], on_timer, 1000)
timer.pause()  # Pause timer
timer.resume() # Resume timer
timer.once = True  # Make it one-shot
\f[R]
.fi
.PP
\f[B]Methods:\f[R]
.SS \f[V]cancel() -> None\f[R]
.PP
Cancel the timer and remove it from the timer system.
.PP
Note:
.PP
\f[B]Returns:\f[R] None The timer will no longer fire and cannot be
restarted.
The callback will not be called again.
.SS \f[V]pause() -> None\f[R]
.PP
Pause the timer, preserving the time remaining until next trigger.
.PP
Note:
.PP
\f[B]Returns:\f[R] None The timer can be resumed later with resume().
Time spent paused does not count toward the interval.
.SS \f[V]restart() -> None\f[R]
.PP
Restart the timer from the beginning.
.PP
Note:
.PP
\f[B]Returns:\f[R] None Resets the timer to fire after a full interval
from now, regardless of remaining time.
.SS \f[V]resume() -> None\f[R]
.PP
Resume a paused timer from where it left off.
.PP
Note:
.PP
\f[B]Returns:\f[R] None Has no effect if the timer is not paused.
Timer will fire after the remaining time elapses.
.SS UICollection
.PP
Iterable, indexable collection of UI objects
.PP
\f[B]Methods:\f[R]
.SS \f[V]append(element)\f[R]
.PP
Add an element to the end of the collection.
.SS \f[V]count(element) -> int\f[R]
.PP
Count occurrences of element in the collection.
.SS \f[V]extend(iterable)\f[R]
.PP
Add all elements from an iterable to the collection.
.SS \f[V]find(name, recursive=False) -> element or list\f[R]
.PP
Find elements by name.
.PP
\f[B]Returns:\f[R] Single element if exact match, list if wildcard, None
if not found.
.SS \f[V]index(element) -> int\f[R]
.PP
Return index of first occurrence of element.
Raises ValueError if not found.
.SS \f[V]insert(index, element)\f[R]
.PP
Insert element at index.
Like list.insert(), indices past the end append.
.PP
Note: If using z_index for sorting, insertion order may not persist
after the next render.
Use name-based .find() for stable element access.
.SS \f[V]pop([index]) -> element\f[R]
.PP
Remove and return element at index (default: last element).
.PP
Note: If using z_index for sorting, indices may shift after render.
Use name-based .find() for stable element access.
.SS \f[V]remove(element)\f[R]
.PP
Remove first occurrence of element.
Raises ValueError if not found.
.SS UICollectionIter
.PP
Iterator for a collection of UI objects
.PP
\f[B]Methods:\f[R]
.SS UIEntityCollectionIter
.PP
Iterator for a collection of UI objects
.PP
\f[B]Methods:\f[R]
.SS Vector
.PP
SFML Vector Object
.PP
\f[B]Methods:\f[R]
.SS \f[V]angle() -> float\f[R]
.PP
Get the angle of this vector in radians.
.PP
\f[B]Returns:\f[R] float: Angle in radians from positive x-axis
.SS \f[V]copy() -> Vector\f[R]
.PP
Create a copy of this vector.
.PP
\f[B]Returns:\f[R] Vector: New Vector object with same x and y values
.SS \f[V]distance_to(other: Vector) -> float\f[R]
.PP
Calculate the distance to another vector.
.PP
\f[B]Arguments:\f[R] - \f[V]other\f[R]: The other vector
.PP
\f[B]Returns:\f[R] float: Distance between the two vectors
.SS \f[V]dot(other: Vector) -> float\f[R]
.PP
Calculate the dot product with another vector.
.PP
\f[B]Arguments:\f[R] - \f[V]other\f[R]: The other vector
.PP
\f[B]Returns:\f[R] float: Dot product of the two vectors
.SS \f[V]floor() -> Vector\f[R]
.PP
Return a new vector with floored (integer) coordinates.
.PP
Note:
.PP
\f[B]Returns:\f[R] Vector: New Vector with floor(x) and floor(y) Useful
for grid-based positioning.
For a hashable tuple, use the .int property instead.
.SS \f[V]magnitude() -> float\f[R]
.PP
Calculate the length/magnitude of this vector.
.PP
\f[B]Returns:\f[R] float: The magnitude of the vector
.SS \f[V]magnitude_squared() -> float\f[R]
.PP
Calculate the squared magnitude of this vector.
.PP
Note:
.PP
\f[B]Returns:\f[R] float: The squared magnitude (faster than
magnitude()) Use this for comparisons to avoid expensive square root
calculation.
.SS \f[V]normalize() -> Vector\f[R]
.PP
Return a unit vector in the same direction.
.PP
Note:
.PP
\f[B]Returns:\f[R] Vector: New normalized vector with magnitude 1.0 For
zero vectors (magnitude 0.0), returns a zero vector rather than raising
an exception
.SS Window
.PP
Window singleton for accessing and modifying the game window properties
.PP
\f[B]Methods:\f[R]
.SS \f[V]center() -> None\f[R]
.PP
Center the window on the screen.
.PP
Note:
.PP
\f[B]Returns:\f[R] None Only works in windowed mode.
Has no effect when fullscreen or in headless mode.
.SS \f[V]get() -> Window\f[R]
.PP
Get the Window singleton instance.
.PP
Note:
.PP
\f[B]Returns:\f[R] Window: The global window object This is a class
method.
Call as Window.get().
There is only one window instance per application.
.SS \f[V]screenshot(filename: str = None) -> bytes | None\f[R]
.PP
Take a screenshot of the current window contents.
.PP
Note:
.PP
\f[B]Arguments:\f[R] - \f[V]filename\f[R]: Optional path to save
screenshot.
If omitted, returns raw RGBA bytes.
.PP
\f[B]Returns:\f[R] bytes | None: Raw RGBA pixel data if no filename
given, otherwise None after saving Screenshot is taken at the actual
window resolution.
Use after render loop update for current frame.
.SS Constants
